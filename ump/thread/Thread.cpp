/***********************************************************************//**
	@file
***************************************************************************/
#include "ump/thread/Thread.hpp"

namespace ump {
namespace thread {
/***********************************************************************//**
	@brief デストラクタ
***************************************************************************/
Thread::~Thread() {
  stop();
}
/***********************************************************************//**
	@brief 
***************************************************************************/
void Thread::start() {
  start(new std::thread(std::ref(*this)));
}
/***********************************************************************//**
	@brief スレッドを開始する
	@param[in] thread スレッド
***************************************************************************/
void Thread::start(std::thread* thread) {
  stop();
  stop_.reset();
  thread_.reset(thread);
}
/***********************************************************************//**
	@brief スレッドが開始しているか調べる
	@return スレッドが開始しているとき真
***************************************************************************/
bool Thread::isStart() const {
  return bool(thread_);
}
/***********************************************************************//**
	@brief スレッドを停止する
***************************************************************************/
void Thread::stop() {
  decltype(thread_) thread;
  thread_.swap(thread);
  if(thread) {
    assert(std::this_thread::get_id() != thread->get_id());
    stop_.notify();
    thread->join();
  }
}
/***********************************************************************//**
	@brief 
***************************************************************************/
bool Thread::isStop() const {
  return stop_.isNotify();
}
/***********************************************************************//**
	@brief 
***************************************************************************/
void Thread::detach() {
  if(auto thread = std::move(thread_)) {
    thread->detach();
  }
}
/***********************************************************************//**
	@brief 
***************************************************************************/
bool Thread::sleep(int ms) {
  return stop_.wait(ms);
}
/***********************************************************************//**
	@brief 
***************************************************************************/
void Thread::sleep() {
  stop_.wait();
}
/***********************************************************************//**
	@brief 
***************************************************************************/
void Thread::operator()() {
  SetThreadName(GetDemangleName(typeid(*this).name()).c_str());
}
/***********************************************************************//**
	@brief 
***************************************************************************/
void Thread::SetThreadName(const char* name) {
#if defined(UMP_PLATFORM_MAC)
  pthread_setname_np(name);
#endif
}
/***********************************************************************//**
	@brief 
***************************************************************************/
std::string Thread::GetDemangleName(const char* name) {
#if !defined(UMP_PLATFORM_WINDOWS)
  int status;
  auto demangle = abi::__cxa_demangle(name, nullptr, nullptr, &status);
  if(demangle && status == 0) {
    std::string result(demangle);
    free(demangle);
    return result;
  }
#endif
  return std::string(name);
}
/***********************************************************************//**
	$Id$
***************************************************************************/
}
}
